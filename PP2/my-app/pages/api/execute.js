import { exec } from 'child_process';
import fs from 'fs/promises';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import { promisify } from 'util';
import { spawn } from 'child_process';
import os from 'os'; // import used for temp directory

// code generated by chatGPT

// will use docker in next part of project

const execAsync = promisify(exec);

export default async function handler(req, res) {
    if (req.method !== 'POST') {
        return res.status(405).json({ message: 'Method not allowed' });
    }

    const { language, code, input } = req.body;

    // Validate input data
    if (!language || !code) {
        return res.status(400).json({ message: 'Language and code are required.' });
    }

    // Get the system's temporary directory
    const tempDir = os.tmpdir();
    const fileId = uuidv4();
    const filePath = path.join(tempDir, `${fileId}`);

    let fileExtension;
    let compileCommand, runCommand;

    try {
        // Prepare commands for different languages
        switch (language.toLowerCase()) {
            case 'c':
                fileExtension = '.c';
                await fs.writeFile(filePath + fileExtension, code);
                compileCommand = `gcc ${filePath}.c -o ${filePath}.out`;
                runCommand = `${filePath}.out`;
                break;
            case 'c++':
                fileExtension = '.cpp';
                await fs.writeFile(filePath + fileExtension, code);
                compileCommand = `g++ ${filePath}.cpp -o ${filePath}.out`;
                runCommand = `${filePath}.out`;
                break;
            case 'java':
                fileExtension = '.java';
                // Save the Java code into a file named "Main.java"
                // This is necessary because the class name should be Main
                const javaFilePath = path.join(tempDir, 'Main.java'); // Explicitly set file to Main.java
                await fs.writeFile(javaFilePath, code);
                compileCommand = `javac ${javaFilePath}`;
                runCommand = `java -cp ${tempDir} Main`;  // Run the Main class
                break;
            case 'python':
                fileExtension = '.py';
                await fs.writeFile(filePath + fileExtension, code);

                // Check if `python3` or `python` is available
                try {
                    // Try python3 first
                    await execAsync('python3 --version');
                    runCommand = `python3 ${filePath}.py`;
                } catch (error) {
                    // Fallback to python if python3 is not available
                    await execAsync('python --version');
                    runCommand = `python ${filePath}.py`;
                }
                break;
            case 'javascript':
                fileExtension = '.js';
                await fs.writeFile(filePath + fileExtension, code);
                runCommand = `node ${filePath}.js`;
                break;
            default:
                return res.status(400).json({ message: 'Unsupported language' });
        }

        // If there's a compile command, run it
        if (compileCommand) {
            await execAsync(compileCommand);
        }

        // Execute the code with the given input
        const process = spawn(runCommand, { shell: true });

        // Pipe input if provided
        if (input) {
            process.stdin.write(input);
            process.stdin.end();
        }

        // Collect output and errors
        let output = '';
        let error = '';

        process.stdout.on('data', (data) => {
            output += data.toString();
        });

        process.stderr.on('data', (data) => {
            error += data.toString();
        });

        process.on('close', (code) => {
            if (code !== 0) {
                return res.status(400).json({ output: null, errors: error || 'Execution failed.' });
            }
            return res.status(200).json({ output: output || 'No output', errors: null });
        });

        // Ensure you capture unexpected failures and send an error response
        process.on('error', (err) => {
            return res.status(500).json({ output: null, errors: 'Process execution error.' });
        });

    } catch (err) {
        console.error('Execution error:', err);
        return res.status(500).json({ message: 'Server error', error: err.message });
    }
}