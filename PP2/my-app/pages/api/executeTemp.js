import { exec } from 'child_process';
import fs from 'fs/promises';
import { v4 as uuidv4 } from 'uuid';
import path from 'path';
import { promisify } from 'util';
import { spawn } from 'child_process';
import os from 'os'; // import used for temp directory
import prisma from '@lib/prisma'; // Assuming Prisma is set up to access the database

// code generated by chatGPT

// will use docker in next part of project

const execAsync = promisify(exec);

export default async function handler(req, res) {
    if (req.method !== 'POST') {
        return res.status(405).json({ message: 'Method not allowed' });
    }

    const { templateId, input } = req.body;

    // Validate input data
    if (!templateId) {
        return res.status(400).json({ message: 'Template ID is required.' });
    }

    try {
        // Fetch the code template from the database
        const template = await prisma.codeTemplate.findUnique({
            where: { id: templateId },
            select: { code: true, language: true },
        });

        if (!template) {
            return res.status(404).json({ message: 'Code template not found.' });
        }

        let { code, language } = template;
    
        // Get the system's temporary directory
        const tempDir = os.tmpdir();
        const fileId = uuidv4();
        const filePath = path.join(tempDir, `${fileId}`);

        let fileExtension;
        let compileCommand, runCommand;

        // Prepare commands for different languages
        switch (language.name.toLowerCase()) {
            case 'c':
                fileExtension = '.c';
                await fs.writeFile(filePath + fileExtension, code);
                compileCommand = `gcc ${filePath}.c -o ${filePath}.out`;
                runCommand = `${filePath}.out`;
                break;
            case 'c++':
                fileExtension = '.cpp';
                await fs.writeFile(filePath + fileExtension, code);
                compileCommand = `g++ ${filePath}.cpp -o ${filePath}.out`;
                runCommand = `${filePath}.out`;
                break;
            case 'java':
                fileExtension = '.java';
                const javaFilePath = path.join(tempDir, 'Main.java'); // Explicitly set file to Main.java
                await fs.writeFile(javaFilePath, code);
                compileCommand = `javac ${javaFilePath}`;
                runCommand = `java -cp ${tempDir} Main`;
                break;
            case 'python':
                fileExtension = '.py';
                await fs.writeFile(filePath + fileExtension, code);
                try {
                    await execAsync('python3 --version');
                    runCommand = `python3 ${filePath}.py`;
                } catch (error) {
                    await execAsync('python --version');
                    runCommand = `python ${filePath}.py`;
                }
                break;
            case 'javascript':
                fileExtension = '.js';
                await fs.writeFile(filePath + fileExtension, code);
                runCommand = `node ${filePath}.js`;
                break;
            default:
                return res.status(400).json({ message: 'Unsupported language' });
        }

        // If there's a compile command, run it
        if (compileCommand) {
            await execAsync(compileCommand);
        }

        // Execute the code with the given input
        const process = spawn(runCommand, { shell: true });

        if (input) {
            process.stdin.write(input);
            process.stdin.end();
        }

        let output = '';
        let error = '';

        process.stdout.on('data', (data) => {
            output += data.toString();
        });

        process.stderr.on('data', (data) => {
            error += data.toString();
        });

        process.on('close', (code) => {
            if (code !== 0) {
                return res.status(400).json({ output: null, errors: error || 'Execution failed.' });
            }
            return res.status(200).json({ output: output || 'No output', errors: null });
        });

        process.on('error', (err) => {
            return res.status(500).json({ output: null, errors: 'Process execution error.' });
        });

    } catch (err) {
        console.error('Execution error:', err);
        return res.status(500).json({ message: 'Server error', error: err.message });
    }
}
